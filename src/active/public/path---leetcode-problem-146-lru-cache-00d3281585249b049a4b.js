webpackJsonp([80835964421969],{401:function(e,t){e.exports={data:{markdownRemark:{htmlAst:{type:"element",tagName:"div",properties:{},children:[{type:"element",tagName:"paragraph",properties:{},children:[{type:"text",value:"\n  "},{type:"element",tagName:"a",properties:{target:"\\_blank",href:"https://leetcode.com/problems/lru-cache/"},children:[{type:"text",value:"Problem 146 on LeetCode"}]},{type:"text",value:" requires the creation of a Least Recently Used (LFU) cache. An LRU cache is an algorithm that, when it's capacity is reached, removes\n  the least recently used object from memory.\n"}]},{type:"element",tagName:"paragraph",properties:{},children:[{type:"text",value:"\n  The following operations that the LeetCode problem requires are, as stated in the problem statement:\n  "},{type:"element",tagName:"br",properties:{},children:[]},{type:"text",value:"\n  "},{type:"element",tagName:"br",properties:{},children:[]},{type:"text",value:"\n  "},{type:"element",tagName:"ul",properties:{},children:[{type:"text",value:"\n    "},{type:"element",tagName:"li",properties:{},children:[{type:"text",value:"\n      get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.\n    "}]},{type:"text",value:"\n    "},{type:"element",tagName:"li",properties:{},children:[{type:"text",value:"\n      put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.\n    "}]},{type:"text",value:"\n  "}]},{type:"text",value:"\n"}]},{type:"element",tagName:"paragraph",properties:{},children:[{type:"text",value:"\n  The final result, below, has three methods, the get and put methods as required by the problem, and a search method, which is used both by the get and put method.\n"}]},{type:"text",value:"\n```java"},{type:"element",tagName:"div",properties:{},children:[{type:"text",value:"public class LRUCache {\nLinkedList"},{type:"element",tagName:"node",properties:{},children:[{type:"text",value:" log = new LinkedList"},{type:"element",tagName:"node",properties:{},children:[{type:"text",value:"();\nHashMap<Integer, Node> quickRetrievalMap = new HashMap<Integer, Node>();\nint capacity;"}]}]}]},{type:"element",tagName:"div",properties:{className:["gatsby-highlight"]},children:[{type:"text",value:"\n      "},{type:"element",tagName:"pre",properties:{className:["language-text"]},children:[{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"public LRUCache(int capacity) {\n    this.capacity = capacity;\n}\n\npublic int get(int key) {\n    Node node = search(key);\n    if (node != null) {\n        log.remove(node);\n        log.addFirst(node);\n        return node.value;\n    }\n    return -1;\n}\n\npublic void put(int key, int value) {\n    Node node = search(key);\n    if (node != null) {\n        node.value = value;\n        log.remove(node);\n        log.addFirst(node);\n        return;\n    }\n\n    Node newNode = new Node(key, value);\n\n    if (capacity == log.size()) {\n        Node lastNode = log.removeLast();\n        quickRetrievalMap.remove(lastNode.key);\n    }\n\n    quickRetrievalMap.put(key, newNode);\n    log.addFirst(newNode);\n}\n\npublic Node search(int key) {\n    if (quickRetrievalMap.containsKey(key)) {\n        return quickRetrievalMap.get(key);\n    }\n\n    return null;\n}"}]}]},{type:"text",value:"\n      "}]},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"}\nclass Node {\npublic int key;\npublic int value;"}]},{type:"element",tagName:"div",properties:{className:["gatsby-highlight"]},children:[{type:"text",value:"\n      "},{type:"element",tagName:"pre",properties:{className:["language-text"]},children:[{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"public Node(int key, int value) {\n    this.key = key;\n    this.value = value;\n}"}]}]},{type:"text",value:"\n      "}]},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"}"}]},{type:"element",tagName:"div",properties:{className:["gatsby-highlight"]},children:[{type:"text",value:"\n      "},{type:"element",tagName:"pre",properties:{className:["language-text"]},children:[{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"<paragraph>\n  Starting with the definition of the class\n</paragraph>"}]}]},{type:"text",value:"\n      "}]}]},frontmatter:{title:"LeetCode Problem 460 - LFU Cache, Part 1"}}},pathContext:{slug:"/leetcode/problem-146-lru-cache/"}}}});
//# sourceMappingURL=path---leetcode-problem-146-lru-cache-00d3281585249b049a4b.js.map